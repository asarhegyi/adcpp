#ifndef UTILITIES
#define UTILITIES

#include <iostream>		// std::cin, std::clog
#include <fstream>		// std::ifstream, std::ofstream
#include <vector>		// std::vector
#include <stdlib.h>     // exit
#include <iomanip>      // std::setprecision
#include <cstddef>      // NULL
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_vector.h>

#include "split_T.h"
/************************************************************
* fileio class												*
*	This class reads and writes data from a file, count the	*
*	number of lines in it, and parses the lines while		*
*	loading up the time and data vectors.					*
*															*
* Parameters:												*
*		See parameters below.								*
*															*
* Member functions											*
*	count_lines -- count the lines in the input file and	*
*			skip blank and comment lines					*
************************************************************/
class fileio {
	public:
		int verbose;              // verbosity level
		std::string fileName;     // input file name


		// Use constructor to initialize macros and variables
		//fileio();

		//fileio(const fileio& old_sfit);
			// Use automatically generated copy constructor

		//fileio operator = (const fileio& old_sfit);
			// Use automatically generated assign constructor

		// Use destructor to free-up the memory 
		//~fileio();

		// count the line in the input file and skip blank and comment lines
		int count_lines(std::string fileNameIn);

		// load data into time[] and data[] arrays
		int load_data (std::string fileNameIn, std::vector<double>& time, std::vector<double>& data, double fs);

		// read in file content and decimate samples through a recursive running sum filter
		int load_N_decimate(std::string fileNameIn, std::vector<double>& time, std::vector<double>& data, double fs, int decRatioIn);

		// load large set of data intermittently to allow recursive processing 
		int stream_data(bool &openFlag, bool &eofFlag, std::ifstream &inFile, std::string fileNameIn, std::vector<double>& time, std::vector<double>& data, double fs, int blockSize, int numSamples);

		// print the content of a gsl_vector to a file
		void save_vector (const gsl_vector* m, const char* fileName, const char* format, const char* fmode);

		// print the content of a gsl_matrix to a file
		void save_matrix (const gsl_matrix* m, const char* fileName, const char* format, const char* fmode);


};


/************************************************************
* fileio::count_lines -- count the lines in the input file.	*
*		Skip blank and comment lines.						*
*															*
* Parameters												*
*		fileNameIn -- the input file name					*
*															*
* Return													*
*		the function returns with the numbers of lines minus*
*		the blanck and comment lines						*
************************************************************/
inline int fileio::count_lines(std::string fileNameIn)
{
	fileName = fileNameIn;

	int index = 0;			// loop through the lines in the input file
	int skipped = 0;		// number of comment and blank lines being skipped
	std::string line;		// the line that is being read in from file
	std::vector <std::string> fields; // split the line into fields and get rid of the delimiters
	
	std::ifstream inFile(fileName.c_str());
	if (inFile.is_open())
	{
		// File opened successfully
		if (verbose >= 1)
		{
			std::clog << "File " << fileName << " opened successfully in function " << __func__ << std::endl;
			std::clog << "Counting the lines ...\n" << std::endl;
		}

		while ( getline (inFile, line) )
		{
			// split line into fileds and get rid of the delimiters
			split( fields, line, " ,\t", skip_empty::no_empties );
			
			if (fields.size() == 0)
		   	{
				++skipped;
				continue;              // skip blank lines
			}
			else if ( (fields[0].compare("#") == 0) || (fields[0].compare("//") == 0) )
		   	{
				++skipped;
				continue;              // skip comment lines
			} 
			else
				++index;
		}
		inFile.close();

		return(index);
	}
	else
	{
		std::cerr << "Unable to open file " << fileName << " in function " << __func__ <<  std::endl;
		exit(1);
	}

	return(0);
}


/************************************************************
 * fileio::load_data -- loads file content, which is		*
 *		supposed to be one or two columns, into the double	*
 *		arrays time and data. If there is only a single		*
 *		column in the file then it is considered to be the	*
 *		data vector and the time vector is generated by		*
 *		calculating index/fs.								*
 *															*
 * Parameters:												*
 *		fileNameIn -- name of the file to load the data from*
 *		time -- the vector that stores the sampling time	*
 *		data -- the vector that stores the data samples		*
 *		fs   -- sampling frequency							*
 *															*
 * Return:													*
 *		Number of elements loaded into the array			*
 ************************************************************/
inline int fileio::load_data (std::string fileNameIn, std::vector<double>& time, std::vector<double>& data, double fs)
{
	// The vector size starts with 1024 entries and it is
	// incremented by 1024 every time it fills up more
	// than 95% of vsize
	int vsize = 1024;
	time.resize(vsize);
	data.resize(vsize);

	fileName = fileNameIn;
	int index = 0;          // loop through the lines in the input file
	int skipped = 0;        // number of comment and blank lines being skipped
	std::string line;       // the line that is being read in from file
	std::string dimension;  // 1D : data is loaded from file; 2D both time & data are loaded from file
	std::vector <std::string> fields;  // split the line into fields and get rid of the delimiters

	std::ifstream inFile(fileName.c_str());
	if (inFile.is_open())
	{
		// File opened successfully
		if (verbose >= 1)
		{
			std::clog << "File " << fileName << " opened successfully in function " << __func__ << std::endl;
			std::clog << "Reading data from file ...\n" << std::endl;
		}

		// Load data into time[] and data[] arrays
		while ( getline (inFile, line) )
		{
			// split line into fields and get rid of the delimiters
			split( fields, line, " ,\t", skip_empty::no_empties );
			
			if (fields.size() == 0)
		   	{
				++skipped;
				continue;              // skip blank lines
			}
			else if ( (fields[0].compare("#") == 0) || (fields[0].compare("//") == 0) )
		   	{
				++skipped;
				continue;              // skip comment lines
			}
			else if (fields.size() == 1)
			{
				if (dimension.compare("2D") == 0)
				{
					std::cerr << "Data mismatch at line #" << index+skipped+1 << " in file " << fileName << std::endl;
					exit(1);
				}

				dimension = "1D";
				time[index] = index/fs;
				data[index] = strtod(fields[0].c_str(), NULL);
			}
			else
			{
				if (dimension.compare("1D") == 0)
				{
					std::cerr << "Data mismatch at line #" << index+skipped+1 << " in file " << fileName << std::endl;
					exit(1);
				}

				dimension = "2D";
				time[index] = strtod(fields[0].c_str(), NULL);
				data[index] = strtod(fields[1].c_str(), NULL);
			}

			if (index > 0.95*vsize)
			{
				vsize += 1024;
				time.resize(vsize);
				data.resize(vsize);
			}

			fields.clear();
			++index;
		}

		time.resize(index);
		data.resize(index);

		inFile.close();

		return(index);
	}
	else
	{
		std::cerr << "Unable to open file " << fileName << " in function " << __func__ <<  std::endl;
		exit(1);
	}

	return(0);
}


/************************************************************
* fileio::load_N_decimate -- read in file content and		*
*		decimate the samples by using a recursive running	*
*		sum decimation filter.								*
*		This function resembles to load_data but in addition*
*		to loading the content of the file it decimates the	*
*		input samples which allows to run FFT on a reasonable
*		number of samples.									*
*		The decimated samples are stored in the time and	*
*		data vectors. The size of these vectors constrained	*
*		by the caller function and the decimation ratio is	*
*		calculated this constraint.							*
*															*
* Parameters												*
*		fileNameIn -- the input file name					*
*		time -- the vector that stores the sampling time	*
*		data -- the vector that stores the data samples		*
*		fs   -- sampling frequency							*
*		decRatioIn -- decimation ratio						*
*															*
* Return:													*
 *		Number of elements loaded into the array			*
************************************************************/
inline int fileio::load_N_decimate(std::string fileNameIn, std::vector<double>& time, std::vector<double>& data, double fs, int decRatioIn)
{
	// The vector size starts with 1024 entries and it is
	// incremented by 1024 every time it fills up more
	// than 95% of vsize
	int vsize = 1024;
	time.resize(vsize);
	data.resize(vsize);

	fileName = fileNameIn;
	int index = 0;          // loop through the lines in the input file
	int skipped = 0;        // number of comment and blank lines being skipped
	std::string line;       // the line that is being read in from file
	std::string dimension;  // 1D : data is loaded from file; 2D both time & data are loaded from file
	std::vector <std::string> fields;  // split the line into fields and get rid of the delimiters
	double timeBuffer;      // store time temporarily before filtering the data
	double dataBuffer;      // store data temporarily before filtering it

	int decRatio = decRatioIn;
	int decIndex = 0;       // keep track of the index after the decimation
	int length = decRatio;  // length of the moving average
	std::vector<double> storeInput(length,0);  // store input samples for recursive processing
	double comb = 0;        // output of the comb section
	double accumulator = 0; // accumulator initialized to zero
	double rsum_out;        // output of the filter

	std::ifstream inFile(fileName.c_str());
	if (inFile.is_open())
	{
		// File opened successfully
		if (verbose >= 1)
		{
			std::clog << "File " << fileName << " opened successfully in function " << __func__ << std::endl;
			std::clog << "Reading data from file ...\n" << std::endl;
		}

		// Load data into time[] and data[] arrays
		while ( getline (inFile, line) )
		{
			// split line into fields and get rid of the delimiters
			split( fields, line, " ,\t", skip_empty::no_empties );
			
			if (fields.size() == 0)
		   	{
				++skipped;
				continue;              // skip blank lines
			}
			else if ( (fields[0].compare("#") == 0) || (fields[0].compare("//") == 0) )
		   	{
				++skipped;
				continue;              // skip comment lines
			}
			else if (fields.size() == 1)
			{
				if (dimension.compare("2D") == 0)
				{
					std::cerr << "Data mismatch at line #" << index+skipped+1 << " in file " << fileName << std::endl;
					exit(1);
				}

				dimension = "1D";
				timeBuffer = index/fs;
				dataBuffer = strtod(fields[0].c_str(), NULL);
			}
			else
			{
				if (dimension.compare("1D") == 0)
				{
					std::cerr << "Data mismatch at line #" << index+skipped+1 << " in file " << fileName << std::endl;
					exit(1);
				}

				dimension = "2D";
				timeBuffer = strtod(fields[0].c_str(), NULL);
				dataBuffer = strtod(fields[1].c_str(), NULL);
			}

			// Recursive Running Sum filter implementation
			{
				// Comb section: x(n) - x(n-D) 
				comb = dataBuffer - storeInput[index % length];
				storeInput[index % length] = dataBuffer;

				// Integrator section: comb + y[n-1]
				rsum_out = comb + accumulator;
				accumulator = rsum_out;

				// Decimate samples
				if( ((index+1) % decRatio) == 0)
				{
					time[decIndex] = timeBuffer;
					data[decIndex] = rsum_out;
					++decIndex;
				}
			}

			if (decIndex > 0.95*vsize)
			{
				vsize += 1024;
				time.resize(vsize);
				data.resize(vsize);
			}

			fields.clear();
			++index;
		}

		time.resize(decIndex);
		data.resize(decIndex);

		inFile.close();

		return(decIndex);
	}
	else
	{
		std::cerr << "Unable to open file " << fileName << " in function " << __func__ <<  std::endl;
		exit(1);
	}

	return(0);
}


/************************************************************
* fileio::stream_data -- open input file and load blocks of	*
*		data intermittently to vector data. This data is	*
*		processed by the main routine before calling this	*
*		function again to load the next chunk of data.		*
*															*
* Parameters:												*
*		openFlag -- indicate the state of the file			*
*		eofFlag  -- end of file flag						*
*		inFile   -- pointer to the open IO stream			*
*		fileNameIn -- name of the file to load the data from*
*		time -- the vector that stores the sampling time	*
*		data -- the vector that stores the data samples		*
*		fs   -- sampling frequency							*
*		blockSize -- the size of data loaded into vector	*
*					data each time this function get called	*
*		numSamples -- number of samples acquired in the		*
*					previous blocks	so far					*
*															*
* Return:													*
*		Number of elements loaded to vector data			*
************************************************************/
inline int fileio::stream_data(bool &openFlag, bool &eofFlag, std::ifstream &inFile, std::string fileNameIn, std::vector<double>& time, std::vector<double>& data, double fs, int blockSize, int numSamples)
{
	fileName = fileNameIn;
	int index = 0;          // used to loop through the lines in the file provided
	int skipped = 0;        // number of comment and blank lines being skipped
	std::string line;       // the line that is being read in from file
	std::string dimension;  // 1D : data is loaded from file; 2D both time & data are loaded from file
	std::vector <std::string> fields;  // split the line into fields and get rid of the delimiters

	time.resize(blockSize);
	data.resize(blockSize);

	// Open file the first time this function get called
	if (!openFlag)
	{
		inFile.open(fileName.c_str());
		if (inFile.is_open())
		{
			if (verbose >= 1)
			{
				std::clog << "File " << fileName << " opened successfully in function " << __func__ << std::endl;
				std::clog << "Reading data from file ...\n" << std::endl;
			}
			openFlag = true;
		}
		else
		{
			std::cerr << "Unable to open file " << fileName << " in function " << __func__ <<  std::endl;
			exit(1);
		}
	}

	if (inFile.is_open())
	{
		// Load block size chunks of data from file to the data and time vectors
		while ( getline (inFile, line) )
		{
			// split line into fileds and get rid of the delimiters
			split( fields, line, " ,\t", skip_empty::no_empties );
			
			if (fields.size() == 0)
		   	{
				++skipped;
				continue;              // skip blank lines
			}
			else if ( (fields[0].compare("#") == 0) || (fields[0].compare("//") == 0) )
		   	{
				++skipped;
				continue;              // skip comment lines
			}
			else if (fields.size() == 1)
			{
				if (dimension.compare("2D") == 0)
				{
					std::cerr << "Data mismatch at line #" << index+skipped+1 << " in file " << fileName << std::endl;
					exit(1);
				}

				dimension = "1D";
				time[index] = (numSamples+index)/fs;
				data[index] = strtod(fields[0].c_str(), NULL);
			}
			else
			{
				if (dimension.compare("1D") == 0)
				{
					std::cerr << "Data mismatch at line #" << index+skipped+1 << " in file " << fileName << std::endl;
					exit(1);
				}

				dimension = "2D";
				time[index] = strtod(fields[0].c_str(), NULL);
				data[index] = strtod(fields[1].c_str(), NULL);
			}

			if (verbose >= 3)    // print message for debug purposes
				fprintf (stderr, "### Index: %d Data: %g EOF: %d\n", index, data[index], inFile.eof());

			fields.clear();
			index++;

			if ( index == blockSize ) break;
		}

		// If the end of the file is reached close it
		// otherwise keep the input file open
		if (inFile.eof())
		{
			if (verbose >= 3)    // print message for debug purposes
				fprintf (stderr, "### Closing the file.\n### Index: %d EOF: %d\n", index, inFile.eof());

			inFile.close();
			eofFlag = true;
		}
	}
	else
	{
		std::cerr << "File " << fileName << " is closed. Unable to read data from file." << std::endl;
		exit(1);
	}

	return(index);
}


/************************************************************
* fileio::save_vector -- save the content of a gsl_vector	*
*		that was passed in to a file.						*
*															*
* Parameters:												*
*		y      -- the gsl_matrix							*
*		fileName -- C string containing the name of the file*
*					to be opened.							*
*		format -- C string specifies the format of the file	*
*		fmode  -- C string containing a file access mode.	*
*															*
* Return:													*
*		None												*
************************************************************/
inline void fileio::save_vector (const gsl_vector* y, const char* fileName, const char* format, const char* fmode)
{
	FILE *yo_ptr;	
	yo_ptr = fopen (fileName, fmode);
	gsl_vector_fprintf (yo_ptr, y, format);
	fclose(yo_ptr);
}


/************************************************************
* fileio::save_matrix -- save the content of a gsl_matrix	*
*		that was passed in to a file.						*
*															*
* Parameters:												*
*		X      -- the gsl_matrix							*
*		fileName -- C string containing the name of the file*
*					to be opened.							*
*		format -- C string specifies the format of the file	*
*		fmode  -- C string containing a file access mode.	*
*															*
* Return:													*
*		None												*
************************************************************/
inline void fileio::save_matrix (const gsl_matrix* X, const char* fileName, const char* format, const char* fmode)
{
	FILE *Xo_ptr;	
	Xo_ptr = fopen (fileName, fmode);
	gsl_matrix_fprintf (Xo_ptr, X, format);
	fclose(Xo_ptr);
}




  // !!!!!!!!!!!!!!!!!!!!!!!! HERE COMES THE FUNCTIONS THAT HASNT BEEN PORTED OVER INTO THE CLASS !!!!!!!!!!!!!!!!!!



/************************************************************
 * dbl_file2array -- load file content into a double array	*
 *															*
 * Parameters:												*
 *		fileName -- name of the file to load the data from 	*
 *		data -- the array that stores the data				*
 *															*
 * Return:													*
 *		Number of elements loaded into the array			*
 ************************************************************/
int dbl_file2array (std::string fileName, std::vector<double>& data)
{
	// The vector size starts with 1024 entries and it is
	// incremented by 1024 every time it fills up more
	// than 95% of vsize
	int vsize = 1024;
	data.resize(vsize);
	int index = 0;			// used to loop through the lines in the file provided

	std::ifstream inFile(fileName.c_str());

	if (inFile.is_open())
	{
		// File opened successfully
		std::clog << "File " << fileName << " opened successfully. Reading data from file...\n" << std::endl;

		// Load data into data[] array
		while (inFile >> data[index])
		{
			if (index > 0.95*vsize)
			{
				vsize += 1024;
				data.resize(vsize);
			}
			++index;
		}

		data.resize(index);
		inFile.close();

		#ifdef DEBUG
			std::clog << "	Line count: " << index << std::endl;
			std::clog << "	data.size: "  << (int) data.size() << std::endl;
			std::clog << "	data.capacity: " << (int) data.capacity() << std::endl;
			std::clog << "	data.max_size: " << (int) data.max_size() << std::endl << std::endl;
		#endif

		return(index);

	} else
	{
		std::cerr << "Unable to open file " << fileName << std::endl;
		exit(1);
	}

	return(0);
}


/************************************************************
 * dbl_array2file -- dump the content of a double array		*
 * into	a file	NOTE FUNCTION OVERLOADING					*
 *															*
 * Parameters:												*
 *		fileName -- name of the file to print the array to	*
 *		data -- array to print into file					*
 *		N	 -- number of elements to print into file		*
 ************************************************************/
void dbl_array2file (std::string fileName, double data[], int N, std::string mode)
{
	std::ofstream outFile;
	if (mode == "Append")
		outFile.open(fileName.c_str(), std::ofstream::out | std::ofstream::app);
	else
		outFile.open(fileName.c_str(), std::ofstream::out | std::ofstream::trunc);

	int index = 0;
	while (index < N)
	{
		outFile << data[index] << std::endl;
		//outFile << std::setprecision(16) << std::fixed << data[index] << std::endl;
		//outFile << std::setprecision(11) << std::scientific << data[index] << std::endl;
		++index;
	}

	outFile.close();

	std::clog << "Data dumped into file " << fileName << std::endl << std::endl;
}


/************************************************************
 * dbl_array2file -- dump the content of a double vector	*
 * into	a file	NOTE FUNCTION OVERLOADING					*
 *															*
 * Parameters:												*
 *		fileName -- name of the file to print the array to	*
 *		data -- vector to print into file					*
 *		N	 -- number of elements to print into file		*
 ************************************************************/
void dbl_array2file (std::string fileName, std::vector<double>& data, int N, std::string mode)
{
	std::ofstream outFile;
	if (mode == "Append")
		outFile.open(fileName.c_str(), std::ofstream::out | std::ofstream::app);
	else
		outFile.open(fileName.c_str(), std::ofstream::out | std::ofstream::trunc);

	int index = 0;
	while (index < N)
	{
		outFile << data[index] << std::endl;
		//outFile << std::setprecision(11) << std::fixed << data[index] << std::endl;
		//outFile << std::setprecision(11) << std::scientific << data[index] << std::endl;
		++index;
	}

	outFile.close();

	std::clog << "Data dumped into file " << fileName << std::endl << std::endl;
}



#endif
